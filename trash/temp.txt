connected
<ref *1> Socket {
  _events: [Object: null prototype] { error: [Function: noop] },
  _eventsCount: 1,
  _maxListeners: undefined,
  nsp: <ref *2> Namespace {
    _events: [Object: null prototype] {
      connection: [Function: handleConnection]
    },
    _eventsCount: 1,
    _maxListeners: undefined,
    sockets: Map(1) { 'toPgH2ZdM0Gcm043AAAL' => [Circular *1] },
    _preConnectSockets: Map(0) {},
    _fns: [],
    _ids: 0,
    server: Server {
      _events: [Object: null prototype] {},
      _eventsCount: 0,
      _maxListeners: undefined,
      _nsps: [Map],
      parentNsps: Map(0) {},
      parentNamespacesFromRegExp: Map(0) {},
      _path: '/socket.io',
      clientPathRegex: /^\/socket\.io\/socket\.io(\.msgpack|\.esm)?(\.min)?\.js(\.map)?(?:\
?|$)/,
      _connectTimeout: 45000,
      _serveClient: true,
      _parser: [Object],
      encoder: [Encoder],
      opts: [Object],
      _adapter: [class Adapter extends EventEmitter],
      sockets: [Circular *2],
      eio: [Server],
      httpServer: [Server],
      engine: [Server],
      Symbol(shapeMode): false,
      Symbol(kCapture): false
    },
    name: '/',
    adapter: Adapter {
      _events: [Object: null prototype] {},
      _eventsCount: 0,
      _maxListeners: undefined,
      nsp: [Circular *2],
      rooms: [Map],
      sids: [Map],
      encoder: [Encoder],
      Symbol(shapeMode): false,
      Symbol(kCapture): false
    },
    Symbol(shapeMode): false,
    Symbol(kCapture): false
  },
  client: Client {
    sockets: Map(1) { 'toPgH2ZdM0Gcm043AAAL' => [Circular *1] },
    nsps: Map(1) { '/' => [Circular *1] },
    server: Server {
      _events: [Object: null prototype] {},
      _eventsCount: 0,
      _maxListeners: undefined,
      _nsps: [Map],
      parentNsps: Map(0) {},
      parentNamespacesFromRegExp: Map(0) {},
      _path: '/socket.io',
      clientPathRegex: /^\/socket\.io\/socket\.io(\.msgpack|\.esm)?(\.min)?\.js(\.map)?(?:\
?|$)/,
      _connectTimeout: 45000,
      _serveClient: true,
      _parser: [Object],
      encoder: [Encoder],
      opts: [Object],
      _adapter: [class Adapter extends EventEmitter],
      sockets: [Namespace],
      eio: [Server],
      httpServer: [Server],
      engine: [Server],
      Symbol(shapeMode): false,
      Symbol(kCapture): false
    },
    conn: Socket {
      _events: [Object: null prototype],
      _eventsCount: 3,
      _maxListeners: undefined,
      _readyState: 'open',
      upgrading: false,
      upgraded: false,
      writeBuffer: [Array],
      packetsFn: [],
      sentCallbackFn: [],
      cleanupFn: [Array],
      id: 'MMUbEj5Ppmt_yPRLAAAK',
      server: [Server],
      request: [IncomingMessage],
      protocol: 4,
      remoteAddress: '::1',
      pingTimeoutTimer: null,
      pingIntervalTimer: Timeout {
        _idleTimeout: 25000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 184164,
        _onTimeout: [Function (anonymous)],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        Symbol(refed): true,
        Symbol(kHasPrimitive): false,
        Symbol(asyncId): 1937,
        Symbol(triggerId): 0,
        Symbol(kAsyncContextFrame): undefined
      },
      transport: [Polling],
      Symbol(shapeMode): false,
      Symbol(kCapture): false
    },
    encoder: Encoder { replacer: undefined },
    decoder: Decoder { reviver: undefined, _callbacks: [Object] },
    id: 'MMUbEj5Ppmt_yPRLAAAK',
    onclose: [Function: bound onclose],
    ondata: [Function: bound ondata],
    onerror: [Function: bound onerror],
    ondecoded: [Function: bound ondecoded],
    connectTimeout: undefined
  },
  recovered: false,
  data: {},
  connected: true,
  acks: Map(0) {},
  fns: [],
  flags: {},
  server: <ref *3> Server {
    _events: [Object: null prototype] {},
    _eventsCount: 0,
    _maxListeners: undefined,
    _nsps: Map(1) { '/' => [Namespace] },
    parentNsps: Map(0) {},
    parentNamespacesFromRegExp: Map(0) {},
    _path: '/socket.io',
    clientPathRegex: /^\/socket\.io\/socket\.io(\.msgpack|\.esm)?(\.min)?\.js(\.map)?(?:\?|
$)/,
    _connectTimeout: 45000,
    _serveClient: true,
    _parser: {
      protocol: 5,
      PacketType: [Object],
      Encoder: [class Encoder],
      Decoder: [class Decoder extends Emitter],
      isPacketValid: [Function: isPacketValid]
    },
    encoder: Encoder { replacer: undefined },
    opts: { cleanupEmptyChildNamespaces: false },
    _adapter: [class Adapter extends EventEmitter],
    sockets: <ref *2> Namespace {
      _events: [Object: null prototype],
      _eventsCount: 1,
      _maxListeners: undefined,
      sockets: [Map],
      _preConnectSockets: Map(0) {},
      _fns: [],
      _ids: 0,
      server: [Circular *3],
      name: '/',
      adapter: [Adapter],
      Symbol(shapeMode): false,
      Symbol(kCapture): false
    },
    eio: Server {
      _events: [Object: null prototype],
      _eventsCount: 1,
      _maxListeners: undefined,
      middlewares: [],
      clients: [Object],
      clientsCount: 1,
      opts: [Object],
      ws: [WebSocketServer],
      Symbol(shapeMode): false,
      Symbol(kCapture): false
    },
    httpServer: Server {
      maxHeaderSize: undefined,
      insecureHTTPParser: undefined,
      requestTimeout: 300000,
      headersTimeout: 60000,
      keepAliveTimeout: 5000,
      keepAliveTimeoutBuffer: 1000,
      connectionsCheckingInterval: 30000,
      requireHostHeader: true,
      joinDuplicateHeaders: undefined,
      rejectNonStandardBodyWrites: false,
      shouldUpgradeCallback: [Function (anonymous)],
      _events: [Object: null prototype],
      _eventsCount: 5,
      _maxListeners: undefined,
      _connections: 2,
      _handle: [TCP],
      _usingWorkers: false,
      _workers: [],
      _unref: false,
      _listeningId: 2,
      allowHalfOpen: true,
      pauseOnConnect: false,
      noDelay: true,
      keepAlive: false,
      keepAliveInitialDelay: 0,
      highWaterMark: 16384,
      httpAllowHalfOpen: false,
      timeout: 0,
      maxHeadersCount: null,
      maxRequestsPerSocket: 0,
      _connectionKey: '6::::3456',
      Symbol(IncomingMessage): [Function: IncomingMessage],
      Symbol(ServerResponse): [Function: ServerResponse],
      Symbol(OptimizeEmptyRequestsOption): false,
      Symbol(shapeMode): false,
      Symbol(kCapture): false,
      Symbol(async_id_symbol): 720,
      Symbol(kUniqueHeaders): null,
      Symbol(http.server.connections): ConnectionsList {},
      Symbol(http.server.connectionsCheckingInterval): Timeout {
        _idleTimeout: 30000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 180207,
        _onTimeout: [Function: bound checkConnections],
        _timerArgs: undefined,
        _repeat: 30000,
        _destroyed: false,
        Symbol(refed): false,
        Symbol(kHasPrimitive): false,
        Symbol(asyncId): 722,
        Symbol(triggerId): 721,
        Symbol(kAsyncContextFrame): undefined
      }
    },
    engine: Server {
      _events: [Object: null prototype],
      _eventsCount: 1,
      _maxListeners: undefined,
      middlewares: [],
      clients: [Object],
      clientsCount: 1,
      opts: [Object],
      ws: [WebSocketServer],
      Symbol(shapeMode): false,
      Symbol(kCapture): false
    },
    Symbol(shapeMode): false,
    Symbol(kCapture): false
  },
  adapter: <ref *4> Adapter {
    _events: [Object: null prototype] {},
    _eventsCount: 0,
    _maxListeners: undefined,
    nsp: <ref *2> Namespace {
      _events: [Object: null prototype],
      _eventsCount: 1,
      _maxListeners: undefined,
      sockets: [Map],
      _preConnectSockets: Map(0) {},
      _fns: [],
      _ids: 0,
      server: [Server],
      name: '/',
      adapter: [Circular *4],
      Symbol(shapeMode): false,
      Symbol(kCapture): false
    },
    rooms: Map(1) { 'toPgH2ZdM0Gcm043AAAL' => [Set] },
    sids: Map(1) { 'toPgH2ZdM0Gcm043AAAL' => [Set] },
    encoder: Encoder { replacer: undefined },
    Symbol(shapeMode): false,
    Symbol(kCapture): false
  },
  id: 'toPgH2ZdM0Gcm043AAAL',
  handshake: {
    headers: {
      host: 'localhost:3456',
      connection: 'keep-alive',
      'sec-ch-ua-platform': '"Windows"',
      'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, l
ike Gecko) Chrome/144.0.0.0 Safari/537.36 Edg/144.0.0.0',
      accept: '*/*',
      'sec-ch-ua': '"Not(A:Brand";v="8", "Chromium";v="144", "Microsoft Edge";v="144"',    
      'sec-ch-ua-mobile': '?0',
      'sec-fetch-site': 'same-origin',
      'sec-fetch-mode': 'cors',
      'sec-fetch-dest': 'empty',
      referer: 'http://localhost:3456/chat',
      'accept-encoding': 'gzip, deflate, br, zstd',
      'accept-language': 'sv,en;q=0.9,en-GB;q=0.8,en-US;q=0.7',
      cookie: 'connect.sid=s%3A2XGB4rdXhe7FqxvU1eEEHh5QAsG1tWHa.EGrzTd%2FGmuPdiqf1W9GygSObR
DR9rx%2BIIj6yCJy20x0'
    },
    time: 'Thu Jan 22 2026 09:38:27 GMT+0100 (centraleuropeisk normaltid)',
    address: '::1',
    xdomain: false,
    secure: false,
    issued: 1769071107353,
    url: '/socket.io/?EIO=4&transport=polling&t=79el1z8v',
    query: { EIO: '4', transport: 'polling', t: '79el1z8v' },
    auth: {}
  },
  Symbol(shapeMode): false,
  Symbol(kCapture): false
}


{
      "id": 0,
      "author": 1769015182417,
      "timeStamp": 1769430580200,
      "content": "wdasdwd"
   },
   {
      "id": 0,
      "author": 1769015182417,
      "timeStamp": 1769430407464,
      "content": "dwasd"
   },
   {
      "id": 0,
      "author": 1769015182417,
      "timeStamp": 1769430179369,
      "content": "dawdasd"
   },
   {
      "id": 0,
      "author": 1769015182417,
      "timeStamp": 1769430112850,
      "content": "dwasdw"
   },
   {
      "id": 0,
      "author": 1769015182417,
      "timeStamp": 1769414412305,
      "content": "jyhfthft"
   },
   {
      "id": 0,
      "author": 1769015182417,
      "timeStamp": 1769364317158,
      "content": "Test"
   },
   {
      "id": 0,
      "author": 1769015182417,
      "timeStamp": 1769348498899,
      "content": ":)("
   },
   {
      "id": 0,
      "author": 1769348401386,
      "timeStamp": 1769348479416,
      "content": "Nah jk"
   },
   {
      "id": 0,
      "author": 1769348401386,
      "timeStamp": 1769348470821,
      "content": "Si"
   },
   {
      "id": 0,
      "author": 1769015182417,
      "timeStamp": 1769348469073,
      "content": "Eller är det det?"
   },
   {
      "id": 0,
      "author": 1769015182417,
      "timeStamp": 1769348465901,
      "content": "Hoppsan det är Love"
   },
   {
      "id": 0,
      "author": 1769348401386,
      "timeStamp": 1769348424641,
      "content": "Hallå där Simonaoiwndawd"
   },
   {
      "id": 0,
      "author": 1769015182417,
      "timeStamp": 1769348044509,
      "content": "ter"
   },
   {
      "id": 0,
      "author": 1769015182417,
      "timeStamp": 1769348044038,
      "content": "per"
   },
   {
      "id": 0,
      "author": 1769015182417,
      "timeStamp": 1769348041334,
      "content": "JagMårBra ver"
   },
   {
      "id": 0,
      "author": 1769015182417,
      "timeStamp": 1769348028554,
      "content": "Hola her"
   },
   {
      "id": 0,
      "author": 1769015182417,
      "timeStamp": 1769348019867,
      "content": "Hallå der"
   },
   {
      "id": 0,
      "author": 1769015182417,
      "timeStamp": 1769345889211,
      "content": "eqdawd"
   },
   {
      "id": 0,
      "author": 1769015182417,
      "timeStamp": 1769343933259,
      "content": "wdasdw"
   },
   {
      "id": 0,
      "author": 1769015182417,
      "timeStamp": 1769267545512,
      "content": "wasdwdasd"
   },
   {
      "id": 0,
      "author": 1769015182417,
      "timeStamp": 1769267334328,
      "content": ":((((())))"
   },
   {
      "id": 0,
      "author": 1769267289760,
      "timeStamp": 1769267321330,
      "content": "MUAHAHAHAHAHHAHA"
   },
   {
      "id": 0,
      "author": 1769015182417,
      "timeStamp": 1769267312145,
      "content": "AAAH!"
   },
   {
      "id": 0,
      "author": 1769267289760,
      "timeStamp": 1769267309176,
      "content": "Buuuoohohoo Jag kommer från Edge"
   },
   {
      "id": 0,
      "author": 1769015182417,
      "timeStamp": 1769267090099,
      "content": "dawdasdwd"
   },
   {
      "id": 0,
      "author": 1769015182417,
      "timeStamp": 1769267075223,
      "content": "Test"
   },
   {
      "id": 0,
      "author": 1769015182417,
      "timeStamp": 1769267067741,
      "content": "Hello does this work"
   },
   {
      "id": 0,
      "author": 1769015182417,
      "timeStamp": 1769267061984,
      "content": "wdasd"
   },
   {
      "id": 0,
      "author": 1769015182417,
      "timeStamp": 1769267041764,
      "content": "adwsda"
   },
   {
      "id": 0,
      "author": 1769015182417,
      "timeStamp": 1769267036968,
      "content": "dwasdwdsdw"
   },
   {
      "id": 0,
      "author": 1769015182417,
      "timeStamp": 1769266954872,
      "content": "Hallå"
   },
   {
      "id": 0,
      "author": 1769015182417,
      "timeStamp": 1769266880128,
      "content": "test"
   },
   {
      "id": 0,
      "author": 1769015182417,
      "timeStamp": 1769266515824,
      "content": "Big"
   },
   {
      "id": 0,
      "author": 1769266193198,
      "timeStamp": 1769266507808,
      "content": "Aa det gör dom"
   },
   {
      "id": 0,
      "author": 1769015182417,
      "timeStamp": 1769266497801,
      "content": "Namn fungerar tror jag"
   },
   {
      "id": 0,
      "author": 1769015182417,
      "timeStamp": 1769266488789,
      "content": "dwasdwd"
   },
   {
      "id": 0,
      "author": "xXTOdjn9fJbs1gXfa_ZUCpHrgFjicziF",
      "timeStamp": 1769266199729,
      "content": "Test"
   },
   {
      "id": 0,
      "author": "Arwe1bNolzxxqHe2kruIIYPVSWyxSAZ8",
      "timeStamp": 1769265273172,
      "content": "This is a really long text and i wanna know if this works and how it will look if This is a really long text and i wanna know if this works and how it will look if This is a really long text and i wanna know if this works and how it will look if This is a really long text and i wanna know if this works and how it will look if This is a really long text and i wanna know if this works and how it will look if This is a really long text and i wanna know if this works and how it will look if This is a really long text and i wanna know if this works and how it will look if This is a really long text and i wanna know if this works and how it will look if"
   },
   {
      "id": 0,
      "author": "Arwe1bNolzxxqHe2kruIIYPVSWyxSAZ8",
      "timeStamp": 1769264688394,
      "content": "dawdasd"
   },
   {
      "id": 0,
      "author": "1Vd52RUu9Z8aG8f4ZEn8agr4Y_lbpP0r",
      "timeStamp": 1769111978050,
      "content": "wdasd"
   },
   {
      "id": 0,
      "author": "53Ai4sH6wBCGOJhLSLVKBLKnwullEfmi",
      "timeStamp": 1769092161489,
      "content": "iubdawdibd"
   },
   {
      "id": 0,
      "author": "53Ai4sH6wBCGOJhLSLVKBLKnwullEfmi",
      "timeStamp": 1769092156178,
      "content": "dwasdwd"
   },
   {
      "id": 0,
      "author": "42ZLo_8iuN8AhQlDB0rT1QaeBPxwi3Mc",
      "timeStamp": 1769092047018,
      "content": "awdawd"
   },
   {
      "id": 0,
      "author": "42ZLo_8iuN8AhQlDB0rT1QaeBPxwi3Mc",
      "timeStamp": 1769092057472,
      "content": "Does This Save?"
   },
   {
      "id": 0,
      "author": "42ZLo_8iuN8AhQlDB0rT1QaeBPxwi3Mc",
      "timeStamp": 1769092062816,
      "content": "dabwudb"
   }


//Chatt
app.get("/chat", async (req,res) => {

    let posts = JSON.parse(await fs.readFile("data/posts.json"))
    let users = JSON.parse(await fs.readFile("data/users.json"))

    posts = posts.slice(0,10)

    //Check login
    if(!req.session.loggedIn) return res.redirect("/?error=Must be logged in to chat")

    html = await render(req, "Chat","client.js", `    
        <form action="" id="form">
            <input name="msg" type="text" placeholder="Type Message">
        </form>

        <div id="chat"></div>
        
        <div class="outerDiv">
            ${(await Promise.all( 
                posts.map (async el => {
                    const user = users.find(c => c.id == el.author) || "Unkown"
                    const authorName = user.username || "Unkown"
                    
                    return `
                    <div class="innerDiv">
                        <div class="innerHeader">
                            <div class="profilePicture">

                            </div>
                            <h3>
                                ${authorName}
                            </h3>
                            <div class = "positionBottom">
                                <p>
                                    ${await timeSinceTime(el.timeStamp)}
                                </p>
                            </div>
                        </div>
                        <div class="innerMain">
                            <p>
                                ${el.content}
                            </p>
                        </div>
                    </div>`
                })
            )).join("")}
        </div>

    <div class="bottomDiv">
        <h3 id="bottomInfo">Your website is stuck</h3>
        <button id="LoadButton"> Click to force loading more </button>
    </div>
    <br>


    `)
    res.send(html);
})